# 에러와 예외

<img width="711" height="581" alt="Image" src="https://github.com/user-attachments/assets/e558ec01-e75b-496d-9a2c-2e72a09cfaeb" />

## 에러
- **개발자가 알 수 없는 오류**
- `OutofMemory`, `StackOverflow` ...

## 예외
- **프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류**

### Checked Exception
- **컴파일 타임**에 일어나는 예외
- 반드시 예외를 처리해야 함
    - **컴파일 타임**에 체크되기 때문에 예외 처리를 하지 않는다면 컴파일 자체가 되지 않음
    - `try-catch`문 사용
    - `throws` 사용
- `IOException`, `FileNotFoundException`, `ClassNotFoundException` ...

```
// try - catch 로 예외처리
public static void fileOpen() {
    // 파일을 열고 쓰고 닫는 아주 단순한 로직이어도 이에 대한 예외는 checked exception으로 분류 되기 때문에 반드시 try - catch로 감싸주어야 한다.
    try {
        FileWriter file = new FileWriter("data.txt");
    	file.write("Hello World");
    	file.close();
    } catch(IOException e) {
    	e.printStackTrace();
    }
}

// -------------------------------------------------------------------------

// throws 로 예외처리
public static void fileOpen() throws IOException {
    // 파일을 열고 쓰고 닫는 아주 단순한 로직이어도 이에 대한 예외는 checked exception으로 분류 되기 때문에 반드시 try - catch로 감싸주어야 한다.
    FileWriter file = new FileWriter("data.txt");
    file.write("Hello World");
    file.close();
}
```

### Unchecked Exception
- **런타임**에 일어나는 예외
- `ArithmeticException`, `NullPointerException`, ...

## Exception Wrapping
- `Checked Exception`을 `Unchecked Exception`으로 변환시킴으로써, 컴파일시에 예외 처리를 강제하지 않을 수 있음
- `DAO(Database Access Object)`에서 `SQLException`이라는 `Checked Exception` 발생시, 비즈니스 로직까지 `SQLException`이 `throws`로 전달되어지면 비즈니스 로직까지 특정 DB기술에 종속되어질 수 있음
    - `DAO` 계층에서 `SQLException`을 `DataAccessException`과 같이 `Unchecked Exception`으로 `ExceptionWrraping`하여서 상위 비즈니스 로직으로 `throws`로 전달하면, 상위 계층은 DB의 구체적인 구현 기술을 알 필요가 없어지고, 상위 메소드가 `throws` 선언에 의한 의무가 사라짐으로써 코드가 간결해짐

```
import java.sql.SQLException;

// 1. Unchecked Exception (Runtime Exception)을 상속받는 사용자 정의 예외
// 'DataAccessException'처럼 기술에 독립적인 추상화된 런타임 예외 역할을 합니다.
public class DatabaseException extends RuntimeException {
    
    // 생성자는 원본 예외(cause)를 인자로 받아 보관합니다.
    public DatabaseException(String message, Throwable cause) {
        super(message, cause);
    }
}

// --------------------------------------------------------------------------------

// 2. DAO 계층의 코드 (예외 래핑이 일어나는 곳)
public class UserDao {
    
    // 이 메서드는 Checked Exception인 SQLException을 발생시키는 DB 로직을 호출한다고 가정합니다.
    public void findUser(String userId) {
        
        try {
            // 실제 DB 접근 코드 (여기서 SQLException이 발생할 수 있음)
            // ex: Connection.prepareStatement().executeQuery();
            
            throw new SQLException("SQL 문법 오류가 발생했습니다."); // 예시로 강제 발생
            
        } catch (SQLException e) {
            
            // 3. 핵심: 예외 래핑 (Checked Exception을 Unchecked Exception으로 전환)
            // SQLException을 'DatabaseException'으로 감싸서 던집니다.
            // 원본 예외 e를 새로운 예외의 원인(cause)으로 설정하여 예외 체인을 보존합니다.
            throw new DatabaseException("사용자 조회 중 데이터 접근 오류 발생.", e);
        }
    }
}

// --------------------------------------------------------------------------------

// 3. 서비스 계층의 코드 (예외를 호출하고 처리하는 곳)
public class UserService {
    private final UserDao userDao = new UserDao();

    public void getUserData(String userId) {
        try {
            // Unchecked Exception이므로 'throws' 선언 없이 호출 가능
            userDao.findUser(userId); 
            
        } catch (DatabaseException e) {
            // Unchecked Exception이지만, 필요한 경우 catch하여 복구하거나 로그를 남길 수 있습니다.
            System.err.println("[예외 처리] 데이터베이스 연결에 심각한 문제가 발생했습니다: " + e.getMessage());
            
            // 원본 예외 추적: e.getCause()를 통해 SQLException 정보에 접근 가능
            if (e.getCause() != null) {
                System.err.println("원본 기술 예외 (SQLException): " + e.getCause().getMessage());
            }
            // 사용자에게는 친절한 메시지를 반환하는 등의 처리를 합니다.
            // throw new BusinessException("데이터 처리 실패", e); // 더 상위 레벨의 예외로 다시 전환할 수도 있습니다.
        }
    }
}
```

### 고려해야하는 점
1. **스택 트레이스 손실**
- `throw new CustomException("메시지", originalException);`과 같이 인수로 기존 `Checked Exception`을 전달하지 않으면, 원본에서 발생한 스택 트레이스 정보가 사라질 수 있음

2. **가독성**
- 너무 많은 `Exception Wrapping`을 할 경우 오히려 스택 트레이스가 너무 길어지고 가독성이 떨어질 수 있음

3. **복구 스킵**
- `Checked Exception`을 `Unchecked Exception`로 `Exception Wrapping`시 컴파일러 강제성이 사라짐
    - 복구가 필요한 예외를 무시하고 `try-catch`없이 그대로 전파되어서 프로그램이 비정상 종료될 수 있음

---
# 출처
- https://inpa.tistory.com/entry/JAVA-☕-에러Error-와-예외-클래스Exception-💯-총정리
