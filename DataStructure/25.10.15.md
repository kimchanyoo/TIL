# 해시

## 해시 알고리즘

* 데이터를 빠르게 저장하고 검색하기 위한 알고리즘
* `키(Key)`를 사용하여 `데이터 값(value)`을 조회하는 방법
* 키-값을 `해시 테이블`이라는 데이터 구조에 저장하여 키에 매핑되는 인덱스 값으로 빠르게 찾을 수 있음

<img width="317" height="224" alt="Image" src="https://github.com/user-attachments/assets/265157de-7f7f-4a80-a9a7-79f16feb2cae" />

### 키
* 문자열 혹은 정수 형태로 구성
* 키는 실제 데이터를 찾기 위해 사용되는 고유 식별자
*  Key 값은 해시 함수를 통해 전달되어 처리가 됨

---

### 해시 함수
* 해시 함수 내에서는 키를 `고유 해시값`으로 변환
* 해시 테이블의 해시 인덱스로 저장
    * 해시 인덱스는 데이터의 저장 및 검색에 활용
* 고유한 해시값 데이터는 `고정된 길이의 동일한 크기`의 데이터로 매핑을 수행
    * 고유한 값과 동일한 크기를 갖는 해시로 변환
* 하나의 키가 항상 동일한 해시 값을 생성하도록 설계하게 되어 있어서 데이터 검색 시 원하는 데이터를 빠르게 찾아낼 수 있음
    * 다른 키가 동일한 해시 값을 생성하게 되면 `해시 충돌`이 발생

<img width="800" height="500" alt="Image" src="https://github.com/user-attachments/assets/d1958965-9147-4998-bfb5-35465206d679" />

<img width="601" height="241" alt="Image" src="https://github.com/user-attachments/assets/6e89b4ed-d9fe-4e3a-9d68-0032ab7b9d0b" />

---

### 해시 충돌
* 서로 다른 키가 동일한 해시 값을 가질 때 발생하는 현상

```
key = 10, key = 15인 값이 2개가 존재한다 가정
해시 함수를 통해서 수행을 하면 '해시 값'으로 변환
변환된 해시 값은 해시 테이블 내의 해시 인덱스로 저장이 되는 시점에 '동일한 해시 값'을 가지는 문제가 발생
```

<img width="800" height="400" alt="Image" src="https://github.com/user-attachments/assets/f692fe4c-222a-4c78-b9a4-d12720e5e374" />

#### Separate Chaning (Open Chaining)
* 같은 해시 값을 가진 항목들을 연결 리스트로 관리하는 방법
* 해시 값이 같은 모든 키-값을 하나의 연결리스트에 저장하므로, 충돌 발생시 해당 리스트에 추가하는 방식으로 해결

#### Open Addressing (Closed Hashing)
* 해시 테이블에서 충돌 발생시, 다른 빈 위치를 찾아 데이터를 저장하는 방식
* 선형 탐사, 이차 탐사, 더블 해싱 등의 방법

| 종류 | 설명 | 
| :--- | :--- |
| 선형 탐사(Linear Probing) | 충돌이 발생하면, 연속적인 위치를 검사하여 처음 발견한 빈 공간에 데이터를 저장하는 방식 | 
| 이차 탐사(Quadratic Probing) | 선형 탐사와 비슷하지만, 충돌이 발생하면 제곱 단위로 위치를 이동시켜 데이터를 저장하는 방식 |
| 더블 해싱(Duble Hashing) | 두 개의 해시 함수를 사용하여 충돌이 발생하면, 두 번째 해시 함수를 사용하여 위치를 이동시키고 데이터를 저장하는 방식 |

## 해시 테이블
* 키와 값을 매핑하는 데이터 구조
    * 키를 해시 함수를 사용하여 변환
* 해시 충돌이 발생할 경우 체이닝과 같은 방법을 사용해서 충돌을 해결함

### 버킷(Buckets)
* 해시 테이블에서 해시 값이 동일한 항목들을 저장하는 공간
    * 해시 함수에서 동일한 값이 나오게 되면 함수 충돌이 일어날 수 있기 때문에 이와 같은 공간이 필요
* 하나 이상의 키-값 쌍을 저장할 수 있으며, 버킷 안의 키-값 쌍들은 일반적으로 연결 리스트로 관리

<img width="800" height="500" alt="Image" src="https://github.com/user-attachments/assets/38c2f04a-b5b0-449a-ba6b-00b8fb568ec8" />

## 자바에서의 구현체

<img width="822" height="576" alt="Image" src="https://github.com/user-attachments/assets/d5f88e8a-0345-474e-9210-0bbf9de9dd0a" />

| 종류 | Map 인터페이스와의 관계 | 설명 | 
| :--- | :--- | :--- |
| HashMap | 구현체 | Map 인터페이스를 구현한 클래스로, 해싱 기법을 사용하여 키와 값의 쌍을 저장 | 
| HashTable | 구현체 | Map 인터페이스를 구현한 클래스로, 해싱 기법을 사용하여 키와 값의 쌍을 저장, 동기화된 메소드를 제공하여 스레드에 안전 |
| LinkedHashMap | 구현체 | HashMap의 하위 클래스로, 키-값 쌍을 해시맵에 저장하는 동시에 더블 링크드 리스트에도 입력 순서에 따라 저장 | 
| SortedMap | 상속 인터페이스 | Map 인터페이스의 확장으로, 키의 자연적인 순서로 키-값 쌍을 유지 | 

```
// HashMap
Map<String, Object> hashMap = new HashMap<>();

// HashTable
Map<String, Object> hashtableMap = new Hashtable<>();

// LinkedHashMap
Map<String, Object> linkedHashMap = new LinkedHashMap<>();

// TreeMap
SortedMap<String, Object> sortedMap = new TreeMap<>();
```

### HashMap
* Map 인터페이스를 구현한 클래스 중 하나
* `Hashing` 기법을 사용하여 `Key`와 `Value`를 저장하고, 검색 속도가 빠르다는 장점
* `Key`와 `Value` 값에 모두 `NULL` 값을 허용
    * `Key`에도 `NULL` 값에 들어가거나 `Value`에도 `NULL` 값이 들어갈 수 있음

### HashTable
* Map 인터페이스를 구현한 클래스 중 하나
* HashMap과 다르게 스레드에 안전한 동기화된 메서드를 제공
* 멀티 스레드 환경에서 여러 스레드 환경에서 여러 스레드가 동시에 HashTable을 수정하지 못하게 함
    * 동시성 문제에 대해 더 안전하게 사용
* `NULL key`와 `NULL value`를 허용하지 않음

### LinkedHashMap
* Map 인터페이스의 하나인 HashMap의 하위 클래스
* `키(key)-값(value)` 쌍을 해시맵에 저장하는 동시에 더블 링크드 리스트에도 입력 순서에 따라 저장
* 키와 값에 NULL을 허용하며 키는 중복되지 않음
    * 동일한 키로 데이터를 저장하면, 기본 데이터를 덮어씀


## 개선 예시
```
class Solution {
    public int[] twoSumBruteForce(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[i] + nums[j] == target) {
                    return new int[]{i, j};
                }
            }
        }
        return new int[]{-1, -1};
    }
}
```
### 이 코드의 시간 복잡도는?
* O(N<sup>2</sup>)

### 이 코드의 시간 복잡도를 개선하는 방법
* 해시를 사용하여 O(N)의 결과를 얻을 수 있음

```
import java.util.HashMap;
import java.util.Map;

class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> idx = new HashMap<>();

        for (int i = 0; i < nums.length; i++) {
            int num = nums[i];
            int need = target - num;

            if (idx.containsKey(need)) {
                return new int[]{idx.get(need), i};
            }
            idx.put(num, i);
        }

        return new int[]{-1, -1};
    }
}
```

# 출처
* [[Java/알고리즘] 탐색 알고리즘 : 해시 알고리즘(Hash Algorithm) 이해하기](https://adjh54.tistory.com/490)
* [[자료구조] 해시(Hash)란 무엇인가](https://ablue-1.tistory.com/68)
* [해시 버킷(Hash Buckets)](https://www.databricks.com/kr/glossary/hash-buckets)
* [맵(Map) 이란?](https://healthcoding.tistory.com/51)