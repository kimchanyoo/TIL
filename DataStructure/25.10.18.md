# 힙

## 우선순위 큐 (Priority Queue)
* 큐는 FIFO 형식의 자료구조
* 우선순위 큐는 큐에 우선순위라는 개념을 접목시킨 자료구조
    * 먼저 들어오는 데이터가 아니라, 우선순위가 높은 데이터가 먼저 나가는 형태의 자료구조

## 힙의 정의
* 우선순위 큐를 위해 고안된 완전이진트리 형태의 자료구조
    * 노드를 왼쪽에서 오른쪽으로 하나씩 빠짐없이 채워야함
* 여러 값 중, 최대값과 최소값을 빠르게 찾아내도록 만든 자료구조
* **반정렬 상태(느슨한 정렬 상태)** 를 유지
    * 부모 노드의 키 값이 자식 노드의 키 값보다 항상 큼 / 작음
* 이진탐색트리(BST)와 달리 중복된 값이 허용함

## 힙의 종류

### 최소 힙 (Min Heap)
* 부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진트리
* Key(부모 노드) ≤ Key(자식 노드)

<img width="416" height="324" alt="Image" src="https://github.com/user-attachments/assets/194e14ac-9881-46d8-88cb-9b1ab4389a3d" />

### 최소 힙 (Min Heap)
* 부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진트리
* Key(부모 노드) ≥ Key(자식 노드)

<img width="409" height="328" alt="Image" src="https://github.com/user-attachments/assets/ab85e39a-999b-422a-a456-e8281f676e4e" />

## 힙의 구현
* 배열을 이용하여 구현
* 이진트리에서는 각 노드가 최대 2개의 자식 노드를 가질 수 있음
    * 배열로 구현한 힙에서는 각 노드가 자식 노드를 최대 2개까지 가지게 됨

<img width="800" height="696" alt="Image" src="https://github.com/user-attachments/assets/d801e2a6-fb8b-4e5a-a80f-c4bf6c86b25d" />

```
왼쪽 자식 index = (부모 index) * 2

오른쪽 자식 index = (부모 index) * 2 + 1

부모 index = (자식 index) / 2
```

## 힙의 삽입 (최소 힙)
1. 힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 삽입
2. 부모 노드와 우선 순위를 비교해서 위치가 바뀌어야 하면 바꿈
3. 올바르게 위치할 때까지 2를 반복

<img width="577" height="895" alt="Image" src="https://github.com/user-attachments/assets/25af6e55-967c-421c-9232-28d797d8da3b" />

## 힙의 삭제 (최소 힙)
1. 루트 노드를 반환(삭제)하고 마지막 노드(n)를 루트 노드 자리에 옮김
2. n의 왼쪽, 오른쪽 자식노드 중 더 우선순위가 높은 것과 비교를 진행
3. 올바르게 위치할 때까지 2를 반복

<img width="592" height="634" alt="Image" src="https://github.com/user-attachments/assets/3e33e2f7-83d9-4799-a81f-185d52960996" />

## 파이썬에서의 heapppush 구현
```
def heappush(heap, data):
    heap.append(data)
    # 추가한 원소의 인덱스를 구한다.
    current = len(heap) - 1
    # 현재 원소가 루트(인덱스 0)에 도달하면 종료
    while current > 0:
        # 추가한 원소의 부모 인덱스를 구한다.
        parent = (current - 1) // 2
        if heap[parent] > heap[current]:
            heap[parent], heap[current] = heap[current], heap[parent]
            # 추가한 원소의 인덱스를 갱신한다.
            current = parent
        else:
            break

#테스트 코드
import heapq
h1 = [3, 4, 6, 8, 5, 7]
h2 = [3, 4, 6, 8, 5, 7]
heappush(h1, 2)
heapq.heappush(h2, 2)
print(f"힙 {h1}에 2를 추가한 결과")
print("구현한 함수의 결과: ", h1)
print("heapq 메서드의 결과:", h2)
print()
heappush(h1, 3)
heapq.heappush(h2, 3)
print(f"힙 {h1}에 3을 추가한 결과")
print("구현한 함수의 결과: ", h1)
print("heapq 메서드의 결과:", h2)
```
### 실행 결과
```
힙 [2, 4, 3, 8, 5, 7, 6]에 2를 추가한 결과
구현한 함수의 결과:  [2, 4, 3, 8, 5, 7, 6]
heapq 메서드의 결과: [2, 4, 3, 8, 5, 7, 6]

힙 [2, 3, 3, 4, 5, 7, 6, 8]에 3을 추가한 결과
구현한 함수의 결과:  [2, 3, 3, 4, 5, 7, 6, 8]
heapq 메서드의 결과: [2, 3, 3, 4, 5, 7, 6, 8]
```

## 파이썬에서의 heapppop 구현
```
def heappop(heap):
    if not heap:
        return "Empty Heap!"
    elif len(heap) == 1:
        return heap.pop()

    pop_data, heap[0] = heap[0], heap.pop()
    current, child = 0, 1
    while child < len(heap):
        sibling = child + 1
        if sibling < len(heap) and heap[child] > heap[sibling]:
            child = sibling
        if heap[current] > heap[child]:
            heap[current], heap[child] = heap[child], heap[current]
            current = child
            child = current * 2 + 1
        else:
            break
    return pop_data


#테스트 코드
import heapq
h1 = [3, 4, 6, 8, 5, 7]
h2 = [3, 4, 6, 8, 5, 7]
print(f"힙 {h1}에서 pop한 결과\n")
data1 = heappop(h1)
data2 = heappop(h2)
print("구현한 함수 pop data =", data1)
print("구현한 함수 pop 이후: ", h1)
print()
print("heapq 함수 pop data =", data2)
print("heapq 함수 pop 이후: ", h2)
```
### 실행 결과
```
힙 [3, 4, 6, 8, 5, 7]에서 pop한 결과

구현한 함수 pop data = 3
구현한 함수 pop 이후:  [4, 5, 6, 8, 7]

heapq 함수 pop data = 3
heapq 함수 pop 이후:  [4, 5, 6, 8, 7]
```

# 출처
* [[자료구조] 힙(heap)이란](https://gmlwjd9405.github.io/2018/05/10/data-structure-heap.html)
* [[자료구조] 힙[heap]이란?](https://velog.io/@bada308/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%ED%9E%99heap%EC%9D%B4%EB%9E%80)
* [[자료구조] 힙(heap)이란? - 개념 정리](https://ittrue.tistory.com/324#google_vignette)
* [08장 파이썬으로 힙(heap) 구현하기](https://wikidocs.net/194445)
* [Tech Interview - 힙(Heap)](https://gyoogle.dev/blog/computer-science/data-structure/Heap.html)