# 트리(Graph)

## 정의
* 노드들이 나무 가지처럼 연결된 비선형 계층적 자료구조
* 트리내에 또 다른 트리가 있는 재귀적 자료구조
* 노드(Node)와 엣지(Edge)로 이루어진 자료구조
* 단순 순환(Loop)을 갖지 않고, 연결된 무방향 그래프 구조
* 노드 간에 부모 자식 관계를 갖고 있는 계층형 자료구조이며 모든 자식 노드는 하나의 부모 노드만 가짐
* 노드가 n개인 트리는 항상 n-1개의 간선(edge)을 가짐

<img width="420" height="314" alt="Image" src="https://github.com/user-attachments/assets/a8ec34a8-1730-4035-bcdc-c77297176b2c" />

<img width="740" height="350" alt="Image" src="https://github.com/user-attachments/assets/60d44252-392d-4cae-a9d6-a4733d51a58d" />

## 구성

<img width="600" height="351" alt="Image" src="https://github.com/user-attachments/assets/20dfa535-71fe-4a0e-a402-cdb74cb11079" />

### 노드 (Node)
* 트리를 구성하고 있는 기본 요소
* 노드에는 키 또는 값과 하위 노드에 대한 포인터를 가지고 있음.
* `A, B, C, D, E, F, G, H, I, J`

### 간선 (Edge)
* 노드와 노드 간의 연결선

### 루트 노드 (Root Node)
* 트리 구조에서 부모가 없는 최상위 노드
* `root node : A`

### 부모 노드 (Parent Node)
* 자식 노드를 가진 노드
`H, I`에 부모 노드는 `D`

### 자식 노드 (Child node)
* 부모 노드의 하위 노드
* 노드 `D`의 자식 노드는 `H, I`

### 형제 노드 (Sibling node)
* 같은 부모를 가지는 노드
* `H, I`는 같은 부모를 가지는 형제 노드

### 외부 노드(external node, outer node), 단말 노드 (terminal node), 리프 노드(leaf node)
* 자식 노드가 없는 노드
* `H, I, J, F, G`

### 내부 노드 (internal node, inner node), 비 단말 노드 (non-terminal node), 가지 노드 (branch node)
* 자식 노드 하나 이상 가진 노드
`A, B, C, D, E`

### 깊이 (depth)
* 루트에서 어떤 노드까지의 간선(Edge) 수
* 루트 노드의 깊이 : 0
* `D`의 깊이 : 2

### 높이 (height)
* 어떤 노드에서 리프 노드까지 가장 긴 경로의 간선(Edge) 수
* 리프 노드의 높이 : 0
* `A` 노드의 높이 : 3

<img width="377" height="414" alt="Image" src="https://github.com/user-attachments/assets/75c34586-8dc8-4d78-8825-01084cecf273" />

### Level
* 루트에서 어떤 노드까지의 간선(Edge) 수

### Degree
* 노드의 자식 수
* `Leaf node`의 degree : 0
* `A`의 degree : 2

### Path
* 한 노드에서 다른 한 노드에 이르는 길 사이에 놓여있는 노드들의 순서
* `A & H` 경로 : `A-B-D-H`

### Path Length
* 해당 경로에 있는 총노드의 수
* `A & H` 경로 길이 : 4

### Size
* 자신을 포함한 자손의 노드 수
* 노드 `B`의 size : 6

### Width
* 레벨에 있는 노드 수
* `Level 2 width` : 4

### Breadth
* 리프 노드의 수
* `Breadth` : 5

### Distance
* 두 노드 사이의 최단 경로에 있는 간선(Edge)의 수
* `D`와 `J`의 Distance : 3

### Order
* 부모 노드가 가질 수 있는 최대 자식의 수
* `Order 3`
    * 부모 노드는 최대 3명의 자식을 가질 수 있다.

## 트리 순회 방식

<img width="420" height="314" alt="Image" src="https://github.com/user-attachments/assets/489dbca5-a891-440f-98cc-b8f68102e5e9" />

### 전위 순회(pre-order)
* 각 루트(Root)를 순차적으로 먼저 방문
* Root -> 왼쪽 자식 -> 오른쪽 자식
```
1 → 2 → 4 → 8 → 9 → 5 → 10 → 11 → 3 → 6 → 13 → 7 → 14
```

### 중위 순회(in-order)
* 왼쪽 하위 트리를 방문 후 루트(Root)를 방문하는 방식
* 왼쪽 자식 → Root → 오른쪽 자식
```
8 → 4 → 9 → 2 → 10 → 5 → 11 → 1 → 6 → 13 → 3 →14 → 7
```

### 후위 순회(post-order)
* 왼쪽 하위 트리부터 하위를 모두 방문 후 루트(Root)를 방문하는 방식
* 왼쪽 자식 → 오른쪽 자식 → Root
```
8 → 9 → 4 → 10 → 11 → 5 → 2 → 13 → 6 → 14 → 7 → 3 → 1
```

### 레벨 순회(level-order)
* 루트(Root)부터 계층 별로 방문하는 방식
```
1 → 2 → 3 → 4 → 5 → 6 → 7 → 8 → 9 → 10 → 11 → 13 → 14
```

## 트리가 아닌 경우

* 루트 노드가 2개(2, 8) 있으므로 트리가 아님

<img width="364" height="337" alt="Image" src="https://github.com/user-attachments/assets/e75e0034-1747-4f1d-bf36-e37816f4531e" />

* 노드 6에는 2명의 부모 노드(8,5)가 있고 사이클(2-8-6-5)이 형성되므로 트리가 아님

<img width="280" height="337" alt="Image" src="https://github.com/user-attachments/assets/5e528d45-1a17-4cc7-8cc2-bc1989151230" />

## 트리의 종류

### 편향 트리 (skew tree)
* 모든 노드들이 자식을 하나만 가진 트리
* 왼쪽 방향으로 자식을 하나씩만 가질 때 left skew tree, 오른쪽 방향으로 하나씩만 가질 때 right skew tree라고 함

<img width="823" height="384" alt="Image" src="https://github.com/user-attachments/assets/dbf56780-cc3d-4593-bee8-4ba7949855f1" />

### 이진 트리
* 각 노드의 차수(자식 노드)가 2 이하인 트리

### 이진 탐색 트리 (Binary Search Tree, BST)
* 순서화된 이진 트리
* 노드의 왼쪽 자식은 부모의 값보다 작은 값을 가짐
* 노드의 오른쪽 자식은 부모의 값보다 큰 값을 가짐
* 중복된 노드가 없어야 함
* **중위 순회 방식 사용**

#### 시간 복잡도
* 균등 트리
    * 노드 개수가 N개일 때 **O(longN)**
* 편향 트리
    * 노드 개수가 N개일 때 **O(N)**
* 삽입, 검색, 삭제 시간 복잡도는 **트리의 Depth**에 비례

#### 삭제 3가지 case
1. 자식이 없는 leaf 노드일 때 → 그냥 삭제

2. 자식이 1개인 노드일 때 → 지워진 노드에 자식을 올리기

3. 자식이 2개인 노드일 때 → 오른쪽 자식 노드에서 가장 작은 값 or 왼쪽 자식 노드에서 가장 큰 값 올리기

[코드](https://github.com/kimchanyoo/TIL/blob/main/DataStructure/code/binarySearchTree.java)

### m 원 탐색 트리(m-way search tree)
* 최대 m개의 서브 트리를 갖는 탐색 트리
* 이진 탐색 트리의 확장된 형태로 높이를 줄이기 위해 사용함

### 균형 트리 (Balanced Tree, B-Tree)
* m원 탐색 트리에서 높이 균형을 유지하는 트리
* height-balanced m-way tree라고도 함

## 코드
```
public class Tree<T> {
    private Node<T> root;

    public Tree(T rootData) {
        root = new Node<T>();
        root.data = rootData;
        root.children = new ArrayList<Node<T>>();
    }

    public static class Node<T> {
        private T data;
        private Node<T> parent;
        private List<Node<T>> children;
    }
}
```

# 출처
* [[자료구조] 트리 (Tree)](https://yoongrammer.tistory.com/68)
* [자료구조(Data structure) - 트리(tree)의 기본 개념/용어](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=4717010&logNo=60209552604)
* [[자료구조] 트리 & 트라이 Tree & Trie](https://yelkim0210.tistory.com/157)
* [Tech Interview - Tree](https://gyoogle.dev/blog/computer-science/data-structure/Tree.html)