# 시간 복잡도

## 알고리즘이란?
문제 해결 절차를 체계적으로 기술한 것

* 입력과 출력으로 명시할 수 있는 것을 **문제**라고 함

## 시간복잡도란
입력 값의 크기에 따라 알고리즘이 실행되는데 걸리는 시간을 정량화 한 것

## 시간 복잡도를 나타내는 방식

### 빅오 (Big-O) 표기법
* 입력 크기 N이 커질 때 실행 시간이 얼마나 증가하는지를 나타내는 **성장률**을 나타내는 것
* 예를 들어 입력 크기가 N일 때, O(N)이라면 최악의 경우에도 선형 시간을 초과하지 않는다는 의미

<img width="820" height="579" alt="Image" src="https://github.com/user-attachments/assets/6c433e72-ef80-4843-927b-d8c542a8cb3d" />

---

### O(1)

**상수 (Constant Time)** <br>
* 입력 데이터 크기에 상관없이 언제나 일정한 시간이 걸리는 알고리즘
```
public boolean constantTime(int[] n) {
    return n[0] == 0;
}
```
<img width="400" height="400" alt="Image" src="https://github.com/user-attachments/assets/9b69b38d-f699-4ed3-90b9-b3c4e61fc052" />

### O(logN)

**이진 검색 (binary search)** <br>
* 데이터를 한번 찾을 때마다 반씩 줄어드는 알고리즘

![Image](https://github.com/user-attachments/assets/1067c1ec-cdbd-4094-afb1-e1ccbd8852cd)

```
public int binarySearch(int key, int[] arr, int start, int end) {
    if (start > end) {
        return -1;
    }
    int mid = (start + end) / 2;
    if(arr[mid] == key) {
        return mid;
    } else if (arr[mid] > key) {
        return binarySearch(key, arr, start, mid - 1);
    } else {
        return binarySearch(key, arr, mid - 1, end);
    }
}
```
<img width="400" height="400" alt="Image" src="https://github.com/user-attachments/assets/15a8fa03-77e3-4c93-9814-4541c41092fe" />


### O(N)

**선형 (Linear Time)** <br>
* 입력 데이터의 크기에 비례해서 처리 시간이 걸리는 알고리즘
* n이 1번 늘어날 때마다 처리시간이 1 증가하여 선형적으로 증가
```
public void linearTime(int[] n) {
    for(int i = 0; i< n.length; i++) {
        System.out.println(i);
    }
}
```

<img width="400" height="400" alt="Image" src="https://github.com/user-attachments/assets/7d0d95da-199d-4ad4-98e3-0c20f48fbb9c" />

### O(N<sup>2</sup>)

**제곱 (Quadratic Time)** <br>
* 입력 데이터 n만큼 반복하는데, 그 안에서 n만큼 또 반복할 떄의 표기 방법
* 데이터가 적을 때는 문제 없지만 많아질수록 수직상승한다.
```
public void quadraticTime(int[] n) {
    for(int i = 0; i< n.length; i++) {
        for(int j = 0; j <n.length; j++) {
            System.out.println(i);
        }
    }
}
```

<img width="400" height="400" alt="Image" src="https://github.com/user-attachments/assets/a40f8bf2-175c-4bfe-8c03-a71fcc0a76b9" />

### O(2<sup>N</sup>)

**지수 시간 (Exponential Time)** <br>
* 피보나치 수열로 비유
* 매 함수가 호출될 때마다 2번씩 호출

<img width="400" height="400" alt="Image" src="https://github.com/user-attachments/assets/1751a212-8f07-4496-9129-47a92332eb0d" /> <img width="400" height="400" alt="Image" src="https://github.com/user-attachments/assets/aca0a88d-90af-4b7a-8c1e-5deb7cb91383" />

```
public int fibonacci(int n, int[] r) {
    if (n <= 0) return 0;
    eles if(n == 1) return r[n] = 1;
    return r[n] = fibonacci(n - 1, r) + fibonacci(n - 2, r);
}
```

```
public int fib(int n) {
    if(n <= 1) return n;
    eles return fib(n - 1) + fib(n - 2);
}
```
<img width="400" height="400" alt="Image" src="https://github.com/user-attachments/assets/c20a6bd5-f3ce-4184-b2e0-5b843ccbbced" />

---

## 질문 

### 시간 복잡도가 낮다고 좋은 것인가? - 아님
* A와 B라는 알고리즘이 있을 때 A 알고리즘이 B 알고리즘보다 시간 복잡도가 낮다고 할 때, **A의 상수 계수가 매우 크다면 A가 더 안좋을 수 있음**
* **시간을 줄이기 위해 메모리를 많이 쓰는 경우**가 있을 수 있기 때문에 시간 복잡도가 낮다고 다 좋은 것은 아님
    * 항상 TradeOff가 일어나는 것은 아님
        * 중복 계산이 많거나 임시 배열을 많이 쓰는 경우에는 둘다 높을 수 있음
        * 최적화나 캐시 사용 등을 활용해서 둘다 낮아질 수도 있음 
- 시간 복잡도가 낮게 되는 경우 **구현 난이도가 높아지거나 가독성적 측면에서 실제 코드 구현에서 어려울 수 있음**

---

### 실제 개발에서의 시간 복잡도
* 실제 개발에서는 항상 시간 복잡도를 챙기면서 하기보다는 확장성이나 협업자들을 위한 가독성들을 고려해야하는 경우들도 많음
* **대용량 데이터 처리나 실시간 서비스**와 같이 한번에 서버에 많은 부하를 줄 수 있는 경우에는 시간 복잡도를 고려해야함
    * 부하를 줄이는 방식
        * 캐싱을 이용한 접근 횟수 감소하는 방식
        * 스레드 풀을 설정하여 한번에 접근할 수 있는 이용자의 수 자체를 제한하는 방식
        * 쿼리 최적화
        * 비동기적 처리 및 메시지 큐 활용을 통한 순차 처리


---

# 출처
* https://wikidocs.net/222560
* https://ko.wikipedia.org/wiki/%EC%8B%9C%EA%B0%84_%EB%B3%B5%EC%9E%A1%EB%8F%84
* https://ssdragon.tistory.com/100
* https://www.geeksforgeeks.org/dsa/time-complexity-and-space-complexity/
* https://blog.chulgil.me/algorithm/
