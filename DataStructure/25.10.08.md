# 배열과 리스트

## 배열 (Array)
* 프로그래밍에서 가장 기본적인 구조 중 하나
* 동일한 타입의 데이터를 연속적인 메모리 공간에 저장하는 구조
* **인덱스**를 사용하여 빠르게 데이터에 접근 가능

<img width="400" height="242" alt="Image" src="https://github.com/user-attachments/assets/9ebc80a3-2412-4cf0-9b8e-b82d5e38a29e" />

### 장점
* 인덱스를 통한 빠른 접근 가능
* 구현 난이도가 낮음

### 단점
* 배열의 크기를 늘리거나 줄이는 것이 불가능함
    * 배열의 크기를 미리 예측하기 어려울 때 한계가 있음
* 메모리를 연속적으로 사용하기 때문에 대량의 데이터를 다룰 때 메모리 할당에 제약을 받을 수 있음

```
int[] myArray = new int[10];
```
---

## 배열 회전 프로그램 
<img width="430" height="280" alt="Image" src="https://github.com/user-attachments/assets/15e4aa6f-c060-4114-93ec-ece93828f0e3" />

#### 저글링 알고리즘
최대공약수 gcd를 이용해 집합을 나누어 여러 요소를 한꺼번에 이동시키는 것

<img width="648" height="237" alt="Image" src="https://github.com/user-attachments/assets/808b6d8f-2f47-4460-a305-f442994caae6" />


```
위 그림처럼 배열이 아래와 같다면

arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}

1,2,3을 뒤로 옮길 때, 인덱스를 3개씩 묶고 회전시키는 방법이다.

a) arr [] -> { 4 2 3 7 5 6 10 8 9 1 11 12}

b) arr [] -> {4 5 3 7 8 6 10 11 9 1 2 12}

c) arr [] -> {4 5 6 7 8 9 10 11 12 1 2 3 }
```

[코드](https://github.com/kimchanyoo/TIL/blob/main/DataStructure/code/ArrayRotation.java)

#### 역전 알고리즘
회전시키는 수에 대해 구간을 나누어 reverse로 구현하는 방법
```

d = 2이면

1,2 / 3,4,5,6,7로 구간을 나눈다.

첫번째 구간 reverse -> 2,1

두번째 구간 reverse -> 7,6,5,4,3

합치기 -> 2,1,7,6,5,4,3

합친 배열을 reverse -> 3,4,5,6,7,1,2
```

[코드](https://github.com/kimchanyoo/TIL/blob/main/DataStructure/code/ReversalRotation.java)

---

### 배열의 특정 최대 합 구하기
arr[i]가 있을 때, i * arr[i]의 Sum이 가장 클 때 그 값을 출력하기

회전하면서 최대값을 찾음

```
Input: arr[] = {1, 20, 2, 10}
Output: 72

2번 회전했을 때 아래와 같이 최대값이 나오게 된다.
{2, 10, 1, 20}
20*3 + 1*2 + 10*1 + 2*0 = 72

Input: arr[] = {10, 1, 2, 3, 4, 5, 6, 7, 8, 9};
Output: 330

9번 회전했을 때 아래와 같이 최대값이 나오게 된다.
{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
0*1 + 1*2 + 2*3 ... 9*10 = 330
```

#### 접근 방법
```
arr[i]의 전체 합과 i * arr[i]의 전체 합을 저장할 변수 선언
최종 가장 큰 sum 값을 저장할 변수 선언
배열을 회전시키면서 i * arr[i]의 합의 값을 저장하고, 가장 큰 값을 저장해서 출력
```

[코드](https://github.com/kimchanyoo/TIL/blob/main/DataStructure/code/MaxRotationSum.java)

---

### 특정 배열을 arr[i] = i로 재배열 하기
주어진 배열에서 arr[i]이 가능한 것만 재배열 시키키<br>
arr[i] = i가 없으면 -1로 채운다

```
Input : arr = {-1, -1, 6, 1, 9, 3, 2, -1, 4, -1}
Output : [-1, 1, 2, 3, 4, -1, 6, -1, -1, 9]

Input : arr = {19, 7, 0, 3, 18, 15, 12, 6, 1, 8,
              11, 10, 9, 5, 13, 16, 2, 14, 17, 4}
Output : [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 
         11, 12, 13, 14, 15, 16, 17, 18, 19]
```

#### 접근법
```
arr[i]가 -1이 아니고, arr[i]이 i가 아닐 때가 우선 조건

해당 arr[i] 값을 저장(x)해두고, 이 값이 x일 때 arr[x]를 탐색

arr[x] 값을 저장(y)해두고, arr[x]가 -1이 아니면서 arr[x]가 x가 아닌 동안을 탐색

arr[x]를 x값으로 저장해주고, 기존의 x를 y로 수정
```

[코드](https://github.com/kimchanyoo/TIL/blob/main/DataStructure/code/ArrayFixer.java)

## 리스트 (List)
* 배열과 달리 크기가 가변적인 자료구조
* 리스트에 데이터를 추가하거나 삭제할 때 메모리를 동적 할당
* 내부적으로 **노드**라는 요소를 활용하여 데이터를 저장
    * **노드**는 **Data + 다음 노드를 가리키는 참조(포인터)**
    * 연속적이지 않은 데이터 저장 가능

<img width="800" height="400" alt="Image" src="https://github.com/user-attachments/assets/e27128a3-ec12-4b2d-b886-6c0aa61c0219" />

### 장점
* 크기의 제약없이 데이터를 추가 및 삭제 가능

### 단점
* 특정 인덱스에 접근하려면 처음부터 해당 인덱스로 이동해야 함 **(선형 탐색)**
* `Array`에 비해 속도가 느림

```
List myList = new new ArrayList<>();
```

## ArrayList
* 내부적으로 일반 `Array`를 사용하여 데이터를 저장
* 동적으로 크기가 늘어남

<img width="800" height="479" alt="Image" src="https://github.com/user-attachments/assets/64d32663-1c45-49a8-a1e7-ada72d7714f7" />

### 장점
* 인덱스를 통한 빠른 접근 가능

### 단점
* 중간에 요소 삽입, 삭제시 뒤쪽 모두를 이동시켜야해서 비효율적

### 동작 과정
1. **배열 초기화**
    * 처음 생성시 내부적으로 **작은 크기(보통 10)** 의 배열 할당
2. **용량 부족 감지**
    * 요소를 계속 추가하거나 내부 배열이 꽉 차면 용량 부족을 감지
3. **새 배열 생성**
    * 현재 크기보다 **더 큰(보통 1.5배)** 새로운 배열을 메모리에 할당
4. **데이터 복사**
    * **기존 배열에 있던 모든 요소**를 **더 큰 배열**로 복사
    * N개의 요소를 하나씩 복사해야함
    * `O(N)`
5. **참조 변경**
    * 새로 만든 배열을 사용하도록 **내부 참조** 변경
    * 기존 배열은 **GC(Garbage Collection)** 로 메모리 제거

### 코드
```
List<String> myList = new ArrayList<>();
```
* `List` 인터페이스로 구현한 모든 클래스의 객체로 처리할 수 있음
* `List` 인터페이스는 공통으로 구현된 메서드 제공
* 코드가 특정 구현체계에 종속되지 않음
    * `LinkedList`와 같이 바로 변경 가능

```
ArrayList<String> myList = new ArrayList<>();
```
* `List` 인터페이스의 모든 메서드는 물론, `ArrayList` **클래스 자체에 추가된 모든 메서드** 까지 사용할 수 있음
    * `ensureCapacity(int minCapacity)`
        * ArrayList의 최소용량을 미리 확보
        * 성능을 최적화

## 연결 리스트 (LinkedList)
* 연속적인 메모리 위치에 저장되지 않는 선형 데이터 구조 (포인터로 연결)
* 데이터 요소를 **노드**로 구성하고 있다는 특징이 있음

### 장점
* 동적 크기 조정이 용이
* 삽입과 삭제의 속도가 빠름
    * `Queue`와 `Stack`에서 주로 활용

### 단점
* 특정 위치에 접근하는 경우 **선형 탐색이 필요해 시간이 오래 걸림**
    * 포인터를 따라가야 하기 때문에 느림
* 포인터를 저장하기 위한 별도의 메모리 공간이 필요함

### 단일 LinkedList
* 각 노드가 다음 노드만 참조하는 가장 기본적인 형태

<img width="800" height="252" alt="Image" src="https://github.com/user-attachments/assets/316e57ac-ef54-48ec-a9fd-73c4f6cc9797" />

[코드](https://github.com/kimchanyoo/TIL/blob/main/DataStructure/code/SinglyLinkedList.java)

### 이중 LinkedList (Doubly Linked List)
* 각 노드가 다음 노드와 이전 노드를 모두 참조
* 양방향 탐색

<img width="800" height="183" alt="Image" src="https://github.com/user-attachments/assets/0b980b2e-a9f6-4d45-a26c-3470cd00ccdb" />

[코드](https://github.com/kimchanyoo/TIL/blob/main/DataStructure/code/DoublyLinkedList.java)

### 원형 연결 리스트 (Circular Linked List)
* **마지막 노드**가 null 대신 **첫 번째 노드**를 가리켜 리스트의 시작과 끝이 연결된 형태
* 순환적인 구조

<img width="800" height="222" alt="Image" src="https://github.com/user-attachments/assets/afd30537-1780-4bdb-92b6-907c3b95b41b" />

[코드](https://github.com/kimchanyoo/TIL/blob/main/DataStructure/code/CircularLinkedList.java)

## Array, ArrayList, LinkedList 비교
| 작업 (시간 복잡도) | 배열 (Array) | ArrayList | LinkedList |
| :--- | :--- | :--- | :--- |
| **중간 삽입/삭제** | 느림 `O(N)` | 느림 `O(N)` | **빠름** `O(1)` |
| **특정 인덱스 접근 (조회)** | **매우 빠름** `O(1)` | 빠름 `O(1)` | 느림 `O(N)` |
| **맨 뒤 추가** | 느림 `O(N)` 또는 불가능 (크기 고정) | 빠름 `O(1)` - **평균적** | 빠름 `O(1)` |
| **크기** | 고정적 | 동적 (가변적) | 동적 (가변적) |

### 왜 동일한 Array기반인데 Array와 ArrayList는 특정 인덱스 접근(조회)에서 속도차이가 나나요?
* `ArrayList`는 **래퍼 타입(Integer, Double 등 객체)** 만 저장할 수 있음
* `int`와 같은 기본 타입을 `ArrayList`에 넣거나 뺄 때, 자바는 자동으로 **오토박싱(Autoboxing)** 과 **언박싱(Unboxing)** 작업을 수행하기 때문에 이 과정에서 **속도차이가 나게됨**
    * 오토박싱은 **기본 타입의 값을 자동으로 해당 래퍼 클래스 타입의 객체로 변환**
    * 언박싱은 **래퍼 클래스 타입의 객체를 자동으로 해당 기본 타입의 값으로 변환**

---

### ArrayList는 왜 맨 뒤 추가에서 O(1)인가요? 배열이 확장되면서 O(N)이어야 하는거 아닌가요?
* 대부분의 `add()`작업이 배열에 빈 공간이 있을 때 발생
    * 이 때는 `O(1)`
* N번의 작업 중 단 한번만 `O(N)`의 복사 비용이 발생
* 평균을 내면 `O(1)`에 가까워진다고 간주할 수 있음
* 그러나, 최악의 경우를 기준으로 보면 `O(N)` 비용이 발생하는 것은 사실임

# 출처

* [배열 Array와 LinkedList의 특징](https://thecho7.tistory.com/entry/면접-꿀팁-배열Array과-링크드-리스트Linked-list의-특징#google_vignette)
* [[Java/자료구조] 선형구조 - 연결 리스트 이해하기 : 단순, 이중, 순환 연결리스트](https://adjh54.tistory.com/319)
* [[Java/자료구조] 선형구조 - 순차 리스트(Sequential List) 이해하기 : 배열, 리스트](https://adjh54.tistory.com/317#4)
* [자료구조의 이해: 리스트와 배열의 차이점](https://f-lab.kr/insight/understanding-data-structures?gad_source=1&gad_campaignid=22368870602&gbraid=0AAAAACGgUFfMxTFgKrGnnb40LTNgKiX1B&gclid=Cj0KCQjw9JLHBhC-ARIsAK4PhcrowKuISzIeX5b8_GLEZGS2k4q4CCe40rMoSzyt41t8mBJsukyMSNMaAhsyEALw_wcB)
* [자바 ArrayList 구조 & 사용법 정리](https://inpa.tistory.com/entry/JAVA-%E2%98%95-ArrayList-%EA%B5%AC%EC%A1%B0-%EC%82%AC%EC%9A%A9%EB%B2%95)
* [Tech Interview - Array](https://gyoogle.dev/blog/computer-science/data-structure/Array.html)
* [Tech Interview - Linked List](https://gyoogle.dev/blog/computer-science/data-structure/Linked%20List.html)
* [Tech Interview - Array vs ArrayList vs LinkedList](https://gyoogle.dev/blog/computer-science/data-structure/Array%20vs%20ArrayList%20vs%20LinkedList.html)