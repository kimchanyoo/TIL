# B 트리와 B+ 트리

## M원 검색 트리 (M-way Search Tree)
* 이진 탐색 트리의 차수는 2이기 때문에 높이가 커지게 되는 문제점이 있음
* M원 검색 트리는 차수를 2에서 m개로 늘려 문제를 해결

### 특징
* 각 노드는 `m-1`개의 레코드와 `m`개의 서브트리를 가짐
* 이진 탐색 트리의 확장된 형태로 높이를 줄일 수 있음
* 각 노드안에서는 정렬
* 원소 개수가 `m`개가 아니라 차수가 `m`개인 것이 중요

<img width="703" height="356" alt="Image" src="https://github.com/user-attachments/assets/0f166b7f-852d-426d-a6e1-774cac08d9ff" />

## B 트리
* 모든 단말 노드가 같은 레벨에 있음
* 루트 노드와 단말 노드를 제외한 모든 노드는 `m/2` 이상 `m`이하의 자식을 가짐
* 루트 노드는 적어도 2개의 자식을 가짐
* 각 노드의 원소 수는 최소 `m/2 - 1`개 ~ 최대 `m - 1`개를 가짐

### 삽입
1. 데이터는 항상 단말 노드에 추가
2. 추가될 단말 노드에 여유 공간이 있다면 그냥 삽입, 없다면 분할
3. 분할 규칙은 아래와 같음
    1. 루트 노트가 가득 찬 경우

    <img width="480" height="139" alt="Image" src="https://github.com/user-attachments/assets/cdc00c8e-49c1-421b-96ab-56ee6c4f13dd" />

    2. 루트 노드 이외에 노드가 가득 찼을 경우

    <img width="458" height="130" alt="Image" src="https://github.com/user-attachments/assets/33ed0d9d-b60c-4a39-a582-63d353b7defd" />

**예제**
```
차수가 3인 B-Tree 데이터 삽입 (1, 8, 4, 6, 13, 5, 27, 9)
```
* 1, 8 삽입

<img width="94" height="33" alt="Image" src="https://github.com/user-attachments/assets/a01a001c-fb85-449e-b31b-f5442cbc8b15" />

* 4 삽입 후 분할

<img width="143" height="38" alt="Image" src="https://github.com/user-attachments/assets/ee583515-6060-4eaa-8875-61e2a99577cb" />

<img width="104" height="84" alt="Image" src="https://github.com/user-attachments/assets/d03cfc8a-7e29-4e2f-9f8f-e80d061db1b5" />

* 6 삽입

<img width="141" height="85" alt="Image" src="https://github.com/user-attachments/assets/fe68102b-82e2-46ef-b932-06e61c09c04c" />

* 13 삽입 후 분할

<img width="183" height="89" alt="Image" src="https://github.com/user-attachments/assets/01ed63b0-b5bc-4b04-aefe-c7b11990e704" />

<img width="149" height="85" alt="Image" src="https://github.com/user-attachments/assets/74fe204e-500d-46bb-aaa5-bd50f893af0d" />

* 5 삽입

<img width="186" height="82" alt="Image" src="https://github.com/user-attachments/assets/522de61e-03d2-4b7c-af92-7efd5aeade00" />

* 27 삽입

<img width="225" height="80" alt="Image" src="https://github.com/user-attachments/assets/5155332d-7507-4595-ae92-cd8d264e9593" />

* 9 삽입 후 분할

<img width="266" height="88" alt="Image" src="https://github.com/user-attachments/assets/de327292-d67b-4137-9f2f-2340fc303d4e" />

<img width="237" height="88" alt="Image" src="https://github.com/user-attachments/assets/e3d95197-90cb-4b15-aaea-360dc567a026" />

<img width="233" height="134" alt="Image" src="https://github.com/user-attachments/assets/71ee4fa7-1434-4e6c-9a8a-aef351484f37" />

### 삭제
* 삭제해도 B트리 조건을 만족한다면 아무 과정이 필요없음
    * B트리 구조가 깨진다면 다시 맞춰야함

**예제**
1. 단말 노드 삭제
* **빌리기**
    * 형제 노드가 `m/2 - 1`개 보다 많은 데이터를 가지고 있을 경우

    <img width="465" height="142" alt="Image" src="https://github.com/user-attachments/assets/a86835fc-0ecd-4434-9365-04747289bb72" />

* **결합하기**
    * 형제 노드에서 빌릴 수 없는 경우

    <img width="460" height="142" alt="Image" src="https://github.com/user-attachments/assets/d2c16844-4475-4eb6-985f-9a88ca6735b1" />

2. 단말 노드 이외 노드 삭제
* 대체 키와 위치를 바꾼 뒤 삭제하면 됨
    * 대체 키는 왼쪽 서브트리 중 가장 큰 값 혹은 오른쪽 서브트리 중 가장 작은 값

```
B 트리에서 8 삭제
```
<img width="242" height="138" alt="Image" src="https://github.com/user-attachments/assets/ce26e045-65fa-40c6-93e5-2cfc4d8a69fa" />

* 왼쪽 서브트리 중 가장 큰 값인 6과 자리 변경

<img width="247" height="143" alt="Image" src="https://github.com/user-attachments/assets/06bf6dd4-b4b7-4e4b-9f8c-04e8bb1c6cb4" />

<img width="235" height="132" alt="Image" src="https://github.com/user-attachments/assets/fd323287-fac0-4cb8-ab6b-8a123e7dd1fe" />

## B+ 트리
* B 트리의 변형된 형태
* 데이터의 효율적인 삽입, 검색, 삭제를 추구하는 자료구조
* B- 트리와 달리 삽입, 삭제 연산이 단말 노드에서만 이루어지고 단말 노드끼리 연결리스트로 연결되어 있음

<img width="547" height="196" alt="Image" src="https://github.com/user-attachments/assets/9c3d9114-c4f2-498e-b4c0-c26ed438e550" />

### 삽입
1. 단말 노드가 가득 찬 경우 -> 중간값을 부모 노드로 올리고 분할

```
4를 삽입
4를 넣었더니 노드가 꽉차서 [2] [3, 4]로 분열한 뒤 부모노드로 중간값 3이 올라감
```

<img width="150" height="85" alt="Image" src="https://github.com/user-attachments/assets/9c02ea3a-eb7f-4325-b186-23727490aec4" />

<img width="204" height="88" alt="Image" src="https://github.com/user-attachments/assets/9e9f3d5b-0c8f-49fe-affe-b926e402eb71" />

<img width="211" height="84" alt="Image" src="https://github.com/user-attachments/assets/c5f5a69d-3598-41c2-9c02-d005e8821910" />

2. 내부 노드가 가득 찬 경우

```
5를 삽입
```

<img width="260" height="93" alt="Image" src="https://github.com/user-attachments/assets/641adae8-5d30-485d-acc9-faf3fdee327d" />

* 5를 넣으니 노드가 가득참

<img width="265" height="81" alt="Image" src="https://github.com/user-attachments/assets/c81f455d-0834-40f2-a97b-8b8431a61110" />

* `[3]`, `[4, 5]` 노드로 분열한 뒤 중간값인 4를 부모노드로 올림

<img width="267" height="134" alt="Image" src="https://github.com/user-attachments/assets/c007430c-d490-40f3-9d6a-33d1da8e3ee3" />

* 부모노드도 꽉차서 중간값인 3을 부모로 올리고 `[2]`, `[4]`로 분열
* 중요한 것이 `index set`은 분열할 때 `[3, 4]`으로 되지 않는다는 것

### 삭제
* B+ 트리에서 데이터 삭제는 단말노드에서만 일어나기 때문에 내부노드는 신경쓸 필요가 없음

1. 삭제한 노드가 underflow가 아닐 때 -> 부모 노드만 수정

<img width="155" height="79" alt="Image" src="https://github.com/user-attachments/assets/325d52c9-d973-4553-95c8-8cc75dce48b7" />

<img width="140" height="89" alt="Image" src="https://github.com/user-attachments/assets/cf895236-5a6c-480b-b825-b33733d3fd3d" />

2. 삭제한 노드가 underflow 일때 -> 형제 노드에게 값을 빌린 후 부모 노드 수정

<img width="209" height="86" alt="Image" src="https://github.com/user-attachments/assets/be081bcf-b6cd-4eed-99d9-891dac5b4bfe" />

<img width="172" height="81" alt="Image" src="https://github.com/user-attachments/assets/47e36a5a-95a7-4069-89d4-aa7b5f13acc8" />

3. 형제 노드도 underflow라면?

<img width="317" height="91" alt="Image" src="https://github.com/user-attachments/assets/1fb3b30e-bcc4-4135-8337-f497f70f876e" />

* 4 데이터를 삭제

<img width="312" height="90" alt="Image" src="https://github.com/user-attachments/assets/19d5164f-dec6-4b3b-9694-79c9f281960f" />

* 삭제하였지만 형제노드도 underflow 상태라 병합을 진행

<img width="277" height="81" alt="Image" src="https://github.com/user-attachments/assets/8ee727e3-6bb0-486f-9f33-eba49985929a" />

* 병합 후 부모노드 수정

# 출처
* [[자료구조] B트리와 B+트리 ](https://m.blog.naver.com/shekwl24/222245938621)
* [Tech Interview - B Tree & B+ Tree](https://gyoogle.dev/blog/computer-science/data-structure/B%20Tree%20&%20B+%20Tree.html)